#include	"u.h"
#include 	"mem.h"
#include	"../port/lib.h"
#include 	"dat.h"
#include 	"draw.h"
#include	"fns.h"
#include	"io.h"
#include	<memdraw.h>
#include	"screen.h"

#define	DPRINT	if(1)iprint

enum {
	/* lccr */
/*	Mode0 = 0x0, */
	Mode0 = 0x10000,
	Mode3 = 0x3,
	Mode4 = 0x4,	/* only use mode 3 for Inferno for now */
	Bg0enable = 0x100,
	Bg1enable = 0x200,
	Bg2enable = 0x400,
	/* lcsr */
	EnableCtlr =~0x7
};

typedef struct {
	Vdisplay;
	LCDparam;
	ushort*	palette;
	ushort*	upper;
	ushort*	lower;
} LCDdisplay;

static LCDdisplay	*vd;	// current active display

void
lcd_setcolor(ulong p, ulong r, ulong g, ulong b)
{
	if(p > 255)
		return;
	vd->palette[p] = ((r>>(32-5))<<10) |
			((g>>(32-5))<<5) |
			(b>>(32-5));
}

static void
disablelcd(void)
{
	LcdReg *lcd = LCDREG;
	int i;

	/* if LCD enabled, turn off */
	if(lcd->lcsr & EnableCtlr) {
		lcd->lcsr &= ~EnableCtlr;
	}
}

static void
setlcdmode(LCDdisplay *vd)
{
	LCDmode *p;
	int  clockdiv;
	ulong v, c;
	LcdReg *lcd = LCDREG;

	p = (LCDmode*)&vd->Vmode;

	disablelcd();
	lcd->lccr = 0;	/* reset it */


//	lcd->dbar1 = PADDR(vd->palette);

	// Enable LCD
	lcd->lccr = Mode0 | Bg0enable;
//iprint("lccr=%8.8lux\n", lcd->lccr);
}
static LCDdisplay main_display;	/* TO DO: limits us to a single display */

Vdisplay*
lcd_init(LCDmode *p)
{
	int palsize;
	int fbsize;

	vd = &main_display;
	vd->Vmode = *p;
	vd->LCDparam = *p;
	DPRINT("%dx%dx%d: hz=%d\n", vd->x, vd->y, vd->depth, vd->hz); /* */

	palsize = 256;
	fbsize = palsize*2+(((vd->x*vd->y) * vd->depth) >> 3);
	vd->palette = PAL;
	vd->palette[0] = 0;
	vd->upper = VIDMEMHI;
	vd->bwid = vd->x; /* only 8 bit for now, may implement 16 bit later */
	vd->lower = VIDMEMLO;
	vd->fb = vd->upper;
	DPRINT("  fbsize=%d p=%p u=%p l=%p\n", fbsize, vd->palette, vd->upper, vd->lower); /* */

	setlcdmode(vd);
	return vd;
}

void
lcd_flush(void)
{
//		dcflushall();	/* need more precise addresses */
}

void
blankscreen(int blank)
{
	LcdReg *lcd = LCDREG;
	if(blank)
		lcd->lcsr |= ~EnableCtlr;
	else
		lcd->lcsr |= EnableCtlr;			
}
void cmap(ushort* palette);


#define RGB15(r,g,b)	((r)|(g<<5)|(b<<10))
void
cmap(ushort* palette)
{
	int num, den, i, j;
	int r, g, b, cr, cg, cb, v, p;

	for(r=0,i=0;r!=4;r++) 
		for(v=0;v!=4;v++,i+=16){
			for(g=0,j=v-r;g!=4;g++) 
				for(b=0;b!=4;b++,j++){
			den=r;
			if(g>den) den=g;
			if(b>den) den=b;
			if(den==0)	/* divide check -- pick grey shades */
				cr=cg=cb=v*17;
			else{
				num=17*(4*den+v);
				cr=r*num/den;
				cg=g*num/den;
				cb=b*num/den;
			}
			p = (i+(j&15));

			palette[p] =RGB15(cr*0x01010101,cg*0x01010101,cb*0x01010101);
		}
	}
}

struct charmap {
    unsigned char bitmap[8];
};
const struct charmap
dstxt_charmap[] = {
/*00*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*01*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*02*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*03*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*04*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*05*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*06*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*07*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*08*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*09*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*0a*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*0b*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*0c*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*0d*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*0e*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*0f*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*10*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*11*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*12*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*13*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*14*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*15*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*16*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*17*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*18*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*19*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*1a*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*1b*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*1c*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*1d*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*1e*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*1f*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*20*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*21*/	{ { 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00 } },
/*22*/	{ { 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*23*/	{ { 0x28, 0x28, 0xfe, 0x28, 0xfe, 0x28, 0x28, 0x00 } },
/*24*/	{ { 0x10, 0x7c, 0x80, 0x7c, 0x02, 0x7c, 0x10, 0x00 } },
/*25*/	{ { 0xc2, 0xc4, 0x08, 0x10, 0x20, 0x46, 0x86, 0x00 } },
/*26*/	{ { 0x60, 0x90, 0x60, 0x90, 0x88, 0x84, 0x7a, 0x00 } },
/*27*/	{ { 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*28*/	{ { 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00 } },
/*29*/	{ { 0x20, 0x10, 0x08, 0x08, 0x08, 0x10, 0x20, 0x00 } },
/*2a*/	{ { 0x44, 0x28, 0x10, 0xfe, 0x10, 0x28, 0x44, 0x00 } },
/*2b*/	{ { 0x00, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x00, 0x00 } },
/*2c*/	{ { 0x00, 0x00, 0x00, 0x00, 0x18, 0x08, 0x10, 0x00 } },
/*2d*/	{ { 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00 } },
/*2e*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00 } },
/*2f*/	{ { 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00 } },
/*30*/	{ { 0x7c, 0x86, 0x8a, 0x92, 0xa2, 0xc2, 0x7c, 0x00 } },
/*31*/	{ { 0x10, 0x30, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00 } },
/*32*/	{ { 0x7c, 0x82, 0x04, 0x08, 0x10, 0x20, 0xfe, 0x00 } },
/*33*/	{ { 0x7c, 0x82, 0x02, 0x3c, 0x02, 0x82, 0x7c, 0x00 } },
/*34*/	{ { 0x40, 0x40, 0x84, 0x84, 0xfe, 0x04, 0x04, 0x00 } },
/*35*/	{ { 0xfe, 0x80, 0x80, 0xfc, 0x02, 0x82, 0x7c, 0x00 } },
/*36*/	{ { 0x10, 0x20, 0x40, 0xfc, 0x82, 0x82, 0x7c, 0x00 } },
/*37*/	{ { 0xfe, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00 } },
/*38*/	{ { 0x7c, 0x82, 0x82, 0x7c, 0x82, 0x82, 0x7c, 0x00 } },
/*39*/	{ { 0x7c, 0x82, 0x82, 0x7e, 0x04, 0x08, 0x10, 0x00 } },
/*3a*/	{ { 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00 } },
/*3b*/	{ { 0x00, 0x00, 0x10, 0x00, 0x10, 0x10, 0x20, 0x00 } },
/*3c*/	{ { 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00 } },
/*3d*/	{ { 0x00, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x00, 0x00 } },
/*3e*/	{ { 0x40, 0x20, 0x10, 0x08, 0x10, 0x20, 0x40, 0x00 } },
/*3f*/	{ { 0x7c, 0x82, 0x04, 0x08, 0x10, 0x00, 0x10, 0x00 } },
/*40*/	{ { 0x7c, 0x82, 0xbe, 0xa2, 0xbe, 0x80, 0x7e, 0x00 } },
/*41*/	{ { 0x10, 0x28, 0x44, 0x82, 0xfe, 0x82, 0x82, 0x00 } },
/*42*/	{ { 0xfc, 0x82, 0x82, 0xfc, 0x82, 0x82, 0xfc, 0x00 } },
/*43*/	{ { 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x00 } },
/*44*/	{ { 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00 } },
/*45*/	{ { 0xfe, 0x80, 0x80, 0xfc, 0x80, 0x80, 0xfe, 0x00 } },
/*46*/	{ { 0xfe, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0x00 } },
/*47*/	{ { 0x7c, 0x82, 0x80, 0x8e, 0x82, 0x82, 0x7e, 0x00 } },
/*48*/	{ { 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x00 } },
/*49*/	{ { 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00 } },
/*4a*/	{ { 0x02, 0x02, 0x02, 0x02, 0x02, 0x82, 0x7c, 0x00 } },
/*4b*/	{ { 0x82, 0x8c, 0xb0, 0xc0, 0xb0, 0x8c, 0x82, 0x00 } },
/*4c*/	{ { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfe, 0x00 } },
/*4d*/	{ { 0x82, 0xc6, 0xaa, 0x92, 0x82, 0x82, 0x82, 0x00 } },
/*4e*/	{ { 0x82, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x00 } },
/*4f*/	{ { 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00 } },
/*50*/	{ { 0xfc, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80, 0x00 } },
/*51*/	{ { 0x7c, 0x82, 0x82, 0x82, 0x82, 0x84, 0x7a, 0x00 } },
/*52*/	{ { 0xfc, 0x82, 0x82, 0xfc, 0x88, 0x84, 0x82, 0x00 } },
/*53*/	{ { 0x7c, 0x82, 0x80, 0x7c, 0x02, 0x82, 0x7c, 0x00 } },
/*54*/	{ { 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00 } },
/*55*/	{ { 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00 } },
/*56*/	{ { 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00 } },
/*57*/	{ { 0x82, 0x82, 0x82, 0x92, 0x92, 0x54, 0x28, 0x00 } },
/*58*/	{ { 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82, 0x00 } },
/*59*/	{ { 0x82, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x00 } },
/*5a*/	{ { 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00 } },
/*5b*/	{ { 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00 } },
/*5c*/	{ { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 } },
/*5d*/	{ { 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00 } },
/*5e*/	{ { 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*5f*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00 } },
/*60*/	{ { 0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*61*/	{ { 0x00, 0x00, 0x7e, 0x82, 0x82, 0x86, 0x7a, 0x00 } },
/*62*/	{ { 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0xfc, 0x00 } },
/*63*/	{ { 0x00, 0x00, 0x7e, 0x80, 0x80, 0x80, 0x7e, 0x00 } },
/*64*/	{ { 0x02, 0x02, 0x7e, 0x82, 0x82, 0x82, 0x7e, 0x00 } },
/*65*/	{ { 0x00, 0x00, 0x7c, 0x82, 0xfe, 0x80, 0x7c, 0x00 } },
/*66*/	{ { 0x0e, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x00 } },
/*67*/	{ { 0x00, 0x00, 0x7e, 0x82, 0x7e, 0x02, 0x7c, 0x00 } },
/*68*/	{ { 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x00 } },
/*69*/	{ { 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x38, 0x00 } },
/*6a*/	{ { 0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x70, 0x00 } },
/*6b*/	{ { 0x80, 0x80, 0x86, 0x98, 0xe0, 0x98, 0x86, 0x00 } },
/*6c*/	{ { 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00 } },
/*6d*/	{ { 0x00, 0x00, 0xec, 0x92, 0x92, 0x92, 0x82, 0x00 } },
/*6e*/	{ { 0x00, 0x00, 0xbc, 0xc2, 0x82, 0x82, 0x82, 0x00 } },
/*6f*/	{ { 0x00, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x7c, 0x00 } },
/*70*/	{ { 0x00, 0x00, 0xfc, 0x82, 0xfc, 0x80, 0x80, 0x00 } },
/*71*/	{ { 0x00, 0x00, 0x7e, 0x82, 0x7e, 0x02, 0x02, 0x00 } },
/*72*/	{ { 0x00, 0x00, 0xbe, 0xc0, 0x80, 0x80, 0x80, 0x00 } },
/*73*/	{ { 0x00, 0x00, 0x7e, 0x80, 0x7c, 0x02, 0xfc, 0x00 } },
/*74*/	{ { 0x10, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x0c, 0x00 } },
/*75*/	{ { 0x00, 0x00, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00 } },
/*76*/	{ { 0x00, 0x00, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00 } },
/*77*/	{ { 0x00, 0x00, 0x92, 0x92, 0x92, 0x92, 0x6c, 0x00 } },
/*78*/	{ { 0x00, 0x00, 0x82, 0x44, 0x38, 0x44, 0x82, 0x00 } },
/*79*/	{ { 0x00, 0x00, 0x82, 0x82, 0x7e, 0x02, 0x7c, 0x00 } },
/*7a*/	{ { 0x00, 0x00, 0xfe, 0x0c, 0x30, 0xc0, 0xfe, 0x00 } },
/*7b*/	{ { 0x0c, 0x10, 0x10, 0x20, 0x10, 0x10, 0x0c, 0x00 } },
/*7c*/	{ { 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00 } },
/*7d*/	{ { 0x60, 0x10, 0x10, 0x08, 0x10, 0x10, 0x60, 0x00 } },
/*7e*/	{ { 0x34, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
/*7f*/	{ { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
};
#define Scrbase(n) (((n)*0x800)+0x6000000)
#define Cbase(n) (((n)*0x4000)+0x6000000)
#define TEXTBG_SIZE_256x256 0x0 
#define REG_BG0CNT *(ushort*)0x4000008 
#define REG_BG1CNT *(ushort*)0x400000A 
#define REG_BG2CNT *(ushort*)0x400000C 
#define REG_BG3CNT *(ushort*)0x400000E 
#define BG_COLOR256 0x80 
#define CHAR_SHIFT 2 
#define SCREEN_SHIFT 8 
#define WRAPAROUND 0x1

void
ds_tty_inittext(void)
{
    unsigned short *vp;
    struct charmap *cp;
    unsigned char bits;
    int i, j, r, b;

    vp = (unsigned short *)VRAMZERO;
    for (j = 0; (j < 2); j++) {
        cp = (struct charmap *) &dstxt_charmap[0];
        for (i = 0; (i < 128); i++, cp++) {
            for (r = 0; (r < 8); r++) {
                bits = cp->bitmap[r];
                    for (b = 0; (b < 8); b += 2) {
                        *vp++ = ((bits & (0x80>>b)) ? 1 : 0) |
                          ((bits & (0x40>>b)) ? 0x100 : 0);
                    }
            }
        }
    }
}
#define GBA_IOBASE 0x04000000
void
ds_tty_init(void)
{
    int i;
    volatile unsigned short *pp;

    /* Enable mode 0 */
    *((unsigned short *) (GBA_IOBASE + 0x00)) = 0x0100; /*MODE0|BG0*/
    *((unsigned short *) (GBA_IOBASE + 0x08)) = 0x1080;

    /* Default palete, everything is white :-) */
    pp = (volatile unsigned short *)PALMEM;
    for (i = 255; i; i--)
        pp[i] = 0x7fff;
    pp[0] = 0;
    pp = pp+0x4ff;
    for (i = 255; i; i--)
        pp[i] = 0x7fff;
    pp[0] = 0;
 

    ds_tty_inittext();
}
ushort *bg0map = (ushort*)Scrbase(31);
enum ARM9_power
{
	POWER_LCD,			//!<	Controls the power for both LCD screens.
	POWER_2D_A,			//!<	Controls the power for the main 2D core.
	POWER_MATRIX,		//!<	Controls the power for the 3D matrix.
	POWER_3D_CORE,		//!<	Controls the power for the main 3D core.
	POWER_2D_B,			//!<	Controls the power for the sub 2D core.
	POWER_SWAP_LCDS,	//!<	Controls which screen should use the main core.
};

#define VRAM_A_CR		(*(volatile uchar*)0x04000240)
#define VRAM_ENABLE		(1<<7)
#define POWER_CR       (*(volatile ushort*)0x04000304)
#define POWER_ALL_2D     (POWER_LCD |POWER_2D_A |POWER_2D_B)
#define POWER_ALL		 (POWER_ALL_2D | POWER_3D_CORE | POWER_MATRIX)

void
dsconsinit(void)
{

	ushort i, j;
	ushort *p, *g;
	ushort *palette = ((ushort*)PAL);
	setlcdmode(vd);

	ds_tty_init();
	POWER_CR = POWER_ALL;
	REG_BG0CNT = BG_COLOR256 | TEXTBG_SIZE_256x256 | 
        (31 << SCREEN_SHIFT) | WRAPAROUND;	
	VRAM_A_CR = VRAM_ENABLE;
}
void lcdscroll(void);
static int j;
void
uartputs(char* s, int n) {
	int i, k;
	for(i =0; i < n;  i++, j++) {
		if (s[i] == '\n') {
			j = j + 31 - j%32;
			if(j >= 32*20) 
				lcdscroll();
//			for(k = j; k < j+32; k++)
//				bg0map[k] = 0;
		}
		bg0map[j] = s[i];
	}
}

void
lcdscroll(void) {
	int i; 
	for(i=0; i < j-64; i++)
		bg0map[i] = bg0map[i+64];
	for(; i < j; i++)
		bg0map[i] = 0;
	j -= 64;
}
