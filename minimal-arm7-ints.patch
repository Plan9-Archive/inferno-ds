Index: l.s
===================================================================
--- l.s	(revision 24)
+++ l.s	(working copy)
@@ -1,5 +1,7 @@
 #include "mem.h"
 
+#define	CPWAIT	MRC	CpMMU, 0, R2, C(2), C(0), 0; MOVW R2, R2; SUB $4, R15
+
 /*
  * 		Entered from the boot loader with
  *		supervisor mode, interrupts disabled;
@@ -22,6 +24,10 @@
 
 GLOBL 		Mach0(SB), $KSTACK
 
+TEXT	getcpuid(SB), $-4
+	MRC		CpMMU, 0, R0, C(CpCPUID), C(0)
+	RET
+
 TEXT setr13(SB), $-4
 	MOVW		4(FP), R1
 
@@ -131,7 +137,8 @@
 	RET
 
 TEXT splx(SB), $-4
-	/* BUG - save PC in m->splpc - JB */
+	MOVW	$(MACHADDR), R6
+	MOVW	R14, (R6)	/* m->splpc */
 
 TEXT splxpc(SB), $-4
 	MOVW		R0, R1
@@ -205,23 +212,90 @@
 */
 	RET
 
+/*
+ * flush (invalidate) the whole icache
+ */
+TEXT icflushall(SB), $-4
+_icflushall:
+	MCR	 	CpMMU, 0, R0, C(CpCacheCtl), C(5), 0	/* clean i-cache and branch buffer */
+	CPWAIT
+	RET
 
+/*
+ * invalidate part of i-cache and  invalidate branch target buffer
+ */
+TEXT	icflush(SB), $-4
+	MOVW	4(FP), R1
+	CMP		$(ICACHESIZE/2), R1
+	BGE		_icflushall
+	ADD		R0, R1
+	BIC		$(CACHELINESZ-1), R0
+icflush1:
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(5), 1	/* clean entry */
+	ADD		$CACHELINESZ, R0
+	CMP		R1, R0
+	BLO	icflush1
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(5), 6	/* invalidate branch target buffer */
+	CPWAIT							
+	RET
+
+/*
+ * write back whole data cache and drain write buffer
+ */
+TEXT dcflushall(SB), $-4
+_dcflushall:
+	MOVW		$(DCFADDR), R0
+	ADD		$DCACHESIZE, R0, R1
+dcflushall1:
+	MCR	CpMMU, 0, R0, C(CpCacheCtl), C(2), 5	/* allocate line */
+	ADD		$CACHELINESZ, R0
+	CMP		R1,R0
+	BNE		dcflushall1
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(10), 4	/* drain write buffer */
+	CPWAIT
+	RET
+
+/*
+ * write back a given region and drain write buffer
+ */
+TEXT	dcflush(SB), $-4
+	MOVW	4(FP), R1
+	CMP		$(DCACHESIZE/2), R1
+	BGE		_dcflushall
+	ADD		R0, R1
+	BIC		$(CACHELINESZ-1), R0
+dcflush1:
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(10), 1	/* clean entry */
+	ADD		$CACHELINESZ, R0
+	CMP		R1, R0
+	BLO	dcflush1
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(10), 4	/* drain write buffer */
+	CPWAIT							
+	RET
+
+/* nds specific bios calls, swi, ... */
+
 TEXT _halt(SB), $-4
-	SWI 0x02
+	SWI	0x02
 
 TEXT _reset(SB), $-4
-	SWI 0x0
+	SWI	0x0
 
 /* need to allow kernel to pass args on what to clear */	
 TEXT	_clearregs(SB), $-4
-	MOVW $0x4, R0
-	SWI 0x1
+	MOVW	$0x4, R0
+	SWI	0x1
 
 TEXT _stop(SB), $-4
 	MOVW $0xEAEAEA,R0
 
+TEXT swiDelay(SB), $-4
+	SWI	0x030000
+	RET
+
 TEXT	waitvblank(SB), $-4
-	SWI 0x050000
+	SWI	0x050000
+	RET
 
 TEXT getdtcm(SB), $-4
 	MRC		15,0,R0,C9,C1,0
@@ -232,8 +306,9 @@
 	RET
 
 TEXT writedtcmctl(SB), $-4
-	MCR		15,0,R0,C9,C1,0
+	MCR		CpMMU,0,R0,C9,C1,0
 	RET
+
 TEXT loop(SB), $-4
 wait:
 	B wait
Index: devnds.c
===================================================================
--- devnds.c	(revision 24)
+++ devnds.c	(working copy)
@@ -66,7 +66,7 @@
 static Chan*
 ndsattach(char* spec)
 {
-	kproc("touchread", touchread, nil, 0);
+	if(1)kproc("touchread", touchread, nil, 0);
 	return devattach('T', spec);
 }
 
@@ -97,9 +97,9 @@
 static long
 ndsread(Chan* c, void* a, long n, vlong offset)
 {
-	char *tmp, buf[64];
-	uchar reply[12];
-	int v, p, l;
+	//char *tmp, buf[64];
+	//uchar reply[12];
+	//int v, p, l;
 
 	switch((ulong)c->qid.path){
 	case Qdir:
@@ -118,8 +118,8 @@
 static long
 ndswrite(Chan* c, void* a, long n, vlong)
 {
-	char cmd[64], op[32], *fielnds[6];
-	int nf;
+	//char cmd[64], op[32], *fielnds[6];
+	//int nf;
 	switch((ulong)c->qid.path){
 	case Qctl:
 		break;
@@ -140,10 +140,11 @@
 touchread(void*)
 {
 	int x=0, y=0, dx, dy, buttons, b, oldb=0, n=0;
+
 	for(;;) {
 	//	print("touchread iter\n");
-	//	if(!(IPC->buttons&Pendown))
-	//		continue; // should sleep until the pen is down
+		if(!(IPC->buttons&Pendown))
+			continue; // should sleep until the pen is down
 	//	dx=IPC->touchXpx-x;
 	//	dy=IPC->touchYpx-y;
 	/* have an option for handedness here? right now left handed */
@@ -154,8 +155,13 @@
 			n=500;
 		}
 		mousetrack(buttons, IPC->touchXpx, IPC->touchYpx, 0);
-	//	x=IPC->touchXpx;
-	//	y=IPC->touchYpx;
+		if(1)print("touchread iter %#X %X %X %X\n", 
+			IPC->touchX, IPC->touchY,
+			IPC->touchXpx, IPC->touchYpx );
+		//waitvblank();
+		swiDelay(1000);
+	x=IPC->touchXpx;
+	y=IPC->touchYpx;
 	}
 }
 TransferRegion  *getIPC() {
Index: mem.h
===================================================================
--- mem.h	(revision 24)
+++ mem.h	(working copy)
@@ -48,6 +48,7 @@
 #define KTZERO	(KZERO+0x00008010)
 #define KSTACK	8192			/* Size of kernel stack */
 
+#define FLUSHMEM	0x80000000	/* virtual address reserved for cache flushing */
 #define DCFADDR	FLUSHMEM	/* cached and buffered for cache writeback */
 #define MCFADDR	(FLUSHMEM+(1<<20))	/* cached and unbuffered for minicache writeback */
 #define UCDRAMZERO	0xC8000000	/* base of memory doubly-mapped as uncached */
@@ -59,8 +60,11 @@
  
 #define	EWRAMZERO	0x02000000
 #define	EWRAMTOP	0x023FFFFF
+#define DWRAMZERO	0x0b000000
+#define DWRAMTOP9	0x0b004000
 #define	IWRAMZERO	0x03000000
-#define	IWRAMTOP	0x03007FFF
+#define	IWRAMTOP9	0x03007FFF
+#define IWRAMTOP7	0x3810000
 #define 	LCD			0x04000000	/* LCD controller */
 #define	SPI			0x040001C0	/* serial peripheral interface controller */
 #define	VRAM		0x04000240	/* Vram bank controller */
@@ -72,10 +76,18 @@
 #define	VRAMTOP		0x06800000
 #define	VRAMLO		0x06000000
 #define	VRAMHI		0x0600A000
-#define	INTHAND		0x03007FFC
+#define	INTHAND		0x03007FFC	// (DWRAMTOP9 - 4) ?
 #define	SFRbase		0x04000000
 #define	ROMZERO		0x08000000
+#define EXMEMCNT	0x04000204
 
+#define OAM			0x07000000
+
+#define	CACHELINELOG	5
+#define	CACHELINESZ	(1<<CACHELINELOG)
+#define	DCACHESIZE	(4*1024)
+#define	ICACHESIZE	(8*1024)
+
 /*
  * PSR
  */
@@ -96,6 +108,28 @@
 #define PsrZ		0x40000000	/* zero */
 #define PsrN		0x80000000	/* negative/less than */
 
+/*
+ * Internal MPU coprocessor registers
+ */
+#define CpCPUID	0		/* R: opcode_2 is 0*/
+#define CpCacheID	0		/* R: opcode_2 is 1 */
+#define CpControl	1		/* R/W: control (opcode_2 is 0) */
+#define CpAuxctl	1		/* R/W: auxiliary control (opcode_2 is 1) */
+#define CpTTB		2		/* R/W: translation table base */
+#define CpDAC		3		/* R/W: domain access control */
+#define CpFSR		5		/* R/W: fault status */
+#define CpFAR		6		/* R/W: fault address */
+#define CpCacheCtl	7		/* W: */
+#define CpTLBops	8		/* W: TLB operations */
+#define CpCacheLk	9		/* W: cache lock down */
+#define CpPID		13		/* R/W: Process ID Virtual Mapping */
+#define CpDebug	14		/* R/W: debug registers */
+#define CpAccess	15		/* R/W: Coprocessor Access */
 
+/*
+ * Coprocessors
+ */
+#define CpMMU		15
+#define CpPWR		14
 
 #define TIMERbase	0x04000100	/* timers */
Index: arm7/defaultARM7.c
===================================================================
--- arm7/defaultARM7.c	(revision 24)
+++ arm7/defaultARM7.c	(working copy)
@@ -1,42 +1,108 @@
 #include <u.h>
 #include "../mem.h"
+#include <kern.h>
 #include "nds.h"
 
-s32 getFreeSoundChannel();
+s32 getFreeSoundChannel(void);
+void irqhandler();
 void VblankHandler(void);
-void VcountHandler();
+void VcountHandler(void);
+void CommandProcessCommands(void);
 
-/* need to figure out the interrupt vector g __inter*/
+void setr13(int, ulong *);
+void splhi(void);
+void spllo(void);
+void poweron(int);
+
+/* So we can initialize our own data section and bss */
+extern char bdata[];
+extern char edata[];
+extern char end[];
+
+#define DMTEST if(0)memtest
+void 
+memtest(char val){
+#define pc	((char*)(0x027FF000)) //+0x1000
+/*
+*/
+	int i;
+
+	for (i=0; i < sizeof(TransferRegion); i++){
+			pc[i] += 1;
+			pc[i] &= 0x0F;
+			pc[i] |= val;
+	}
+}
+
+ulong irqstack[4];
+ulong svcstack[4];
+ulong sysstack[4];
+
 int 
 main(int argc, char ** argv) 
 {
+	USED(argc, argv);
+	
+	//setr13(PsrMirq, irqstack+nelem(irqstack));
+	//setr13(PsrMsvc, svcstack+nelem(svcstack));
+	//setr13(PsrMsys, sysstack+nelem(sysstack));
+	
+	DMTEST(0x00);
+	/* fill out the data section by hand */
+	memset(edata, 0, end-edata); 		/* clear the BSS */
+	
+	// Set up the interrupt handler
+	REG_IME = 0;	
+	IRQ_HANDLER = irqhandler; // VcountHandler VblankHandler 
+	REG_IE = IRQ_VBLANK | IRQ_VCOUNT; // ;
+	REG_IF = IRQ_ALL;
+	REG_DISPSTAT = DISP_VBLANK_IRQ;
+	REG_IME = 1;
+	
+	//splhi();
+	DMTEST(0x10);
+	spllo();
+	
 //	readFirmware(0x03FE00,PersonalData,sizeof(PersonalData));
+	
 	poweron(POWER_SOUND);
 	SOUND_CR = SOUND_ENABLE | SOUND_VOL(0x7F);
-	for(;;) {
-		VblankHandler();
-		VcountHandler();
+
+//	for(;;) {
+//		VblankHandler();
+//		VcountHandler();
+//	}
+
+//	irqInit();
+//	initclkirq();
+//	irqset(IRQ_VBLANK, VblankHandler);
+//	setytrig(80);
+//	irqset(IRQ_VCOUNT, VcountHandler);
+//	irqen(IRQ_VBLANK);
+//	irqen(IRQ_VCOUNT);
+
+
+	DMTEST(0x20);
+	// Keep the ARM7 out of main RAM
+	while (1) {
+		DMTEST(0x40);
+		swiWaitForVBlank();
+		swiDelay(2000000);
 	}
-	irqInit();
-	initclkirq();
-	irqset(IRQ_VBLANK, VblankHandler);
-	setytrig(80);
-	irqset(IRQ_VCOUNT, VcountHandler);
-	irqen( IRQ_VBLANK | IRQ_VCOUNT);
-	while (1)
-		swiWaitForVBlank();
+	return 0;
 }
 
-void 
-startSound(int sampleRate, const void* data, u32 bytes, u8 channel, u8 vol,  u8 pan, u8 format) 
+void
+startSound(int rate, const void* data, u32 bytes, u8 chan, u8 vol,  u8 pan, u8 fmt) 
 {
-	SCHANNEL_TIMER(channel)  = SOUND_FREQ(sampleRate);
-	SCHANNEL_SOURCE(channel) = (u32)data;
-	SCHANNEL_LENGTH(channel) = bytes >> 2 ;
-	SCHANNEL_CR(channel)     = SCHANNEL_ENABLE | SOUND_ONE_SHOT | SOUND_VOL(vol) | SOUND_PAN(pan) | (format==1?SOUND_8BIT:SOUND_16BIT);
+	SCHANNEL_TIMER(chan)  = SOUND_FREQ(rate);
+	SCHANNEL_SOURCE(chan) = (u32)data;
+	SCHANNEL_LENGTH(chan) = bytes >> 2 ;
+	SCHANNEL_CR(chan)     = SCHANNEL_ENABLE | SOUND_ONE_SHOT | SOUND_VOL(vol) | SOUND_PAN(pan) | (fmt==1? SOUND_8BIT: SOUND_16BIT);
 }
-s32 
-getFreeSoundChannel()
+
+s32
+getFreeSoundChannel(void)
 {
 	int i;
 	for (i=0; i<16; i++) {
@@ -45,15 +111,18 @@
 	return -1;
 }
 
-
 void
-VcountHandler()
+VcountHandler(void)
 {
 	touchPosition tp = {0,0,0,0,0, 0};
 	static int lastpress = -1;
-	uint16 press=0, x=0, y=0, xpx=0, ypx=0, z1=0, z2=0;
+	uint16 press, x=0, y=0, xpx=0, ypx=0, z1=0, z2=0, batt, aux;
+	int t1,t2;
+	uint32 temp;
+	
 	press = REG_KEYXY;
-	if (!((press^lastpress)&Pendown)) {
+	
+	if (!((press^lastpress) & Pendown)) {
 		touchReadXY(&tp);
 		if ( tp.x == 0 || tp.y == 0 ) {
 			press |= Pendown;
@@ -70,6 +139,11 @@
 		lastpress = press;
 		press |= Pendown;
 	}
+	
+	batt = touchRead(Tscgetbattery);
+	aux  = touchRead(Tscgetaux);
+	temp = touchReadTemperature(&t1, &t2);
+	
 	IPC->touchX			= x; // x/14-24
 	IPC->touchY			= y; // y/18-12
 	IPC->touchXpx		= xpx;
@@ -77,6 +151,15 @@
 	IPC->touchZ1		= z1;
 	IPC->touchZ2		= z2;
 	IPC->buttons		= press;
+	IPC->battery		= batt;
+	IPC->aux			= aux;
+	IPC->tdiode1		= t1;
+	IPC->tdiode2		= t2;
+	IPC->temperature	= temp;
+
+	DMTEST(0x50); 
+	REG_IF |= IRQ_VCOUNT;
+	VBLANK_INTR_WAIT_FLAGS  |= IRQ_VCOUNT;
 }
 
 void
@@ -92,4 +175,24 @@
 			}
 		}
 	}
+
+	memtest(0x50); 
+	DMTEST(0x50); 
+	
+	// Acknowledge interrupts
+	VBLANK_INTR_WAIT_FLAGS  |= IRQ_VBLANK;
+	
+	REG_IF |= IRQ_VBLANK;
 }
+
+void
+irqhandler(){
+	//CommandProcessCommands();
+	if (REG_IF & IRQ_VCOUNT)
+		VcountHandler();
+	if (REG_IF & IRQ_VBLANK)
+		VblankHandler();
+
+	REG_IF = REG_IF;
+}
+
Index: arm7/l.s
===================================================================
--- arm7/l.s	(revision 24)
+++ arm7/l.s	(working copy)
@@ -1,15 +1,34 @@
 #include "mem.h"
 
-TEXT _main(SB), $-4
-	MOVW		$setR12(SB), R12 	/* static base (SB) */
-/*	MOVW		$Mach0(SB), R13 */
+// BUG move to a _main in C, using cpsrr/cpsrw & setr13
+TEXT _main(SB), $0
+	MOVW	$(PsrMirq), R0				/* Switch to IRQ Mode */
+	MOVW	R0, CPSR
+	MOVW	$(IWRAMTOP7 - 0x60), R13	/* Set IRQ stack */
+
+	MOVW	$(PsrMsys), R0				/* Switch to System Mode */
+	MOVW	R0, CPSR
+	MOVW	$(IWRAMTOP7 - 0x260), R13	/* Set System stack */
+
+	B		main(SB)					/* jump to kernel */
+
+/*
+ * 		Entered from the boot loader with
+ *		supervisor mode, interrupts disabled;
+ */
+
+TEXT _amain(SB), $-4
+	MOVW	$setR12(SB), R12 	/* static base (SB) */
+	/* MOVW	$Mach0(SB), R13 */
 	ADD		$(KSTACK-4), R13	/* leave 4 bytes for link */
 
-	MOVW		$(PsrDirq|PsrDfiq|PsrMsvc), R1	/* Switch to SVC mode */
-	MOVW		R1, CPSR
+	MOVW	$(PsrDirq|PsrDfiq|PsrMsvc), R1	/* Switch to SVC mode */
+	MOVW	R1, CPSR
 
+	MOVW	$0, R0		/* int argc */
+	MOVW	$0, R1		/* char *argv[] */
+	BL		main(SB)		/* jump to kernel */
 
-	BL		main(SB)		/* jump to kernel */
 TEXT swiDelay(SB), $-4
 	SWI	0x030000
 	RET
@@ -20,6 +39,7 @@
 TEXT swiDivMod(SB), $-4
 	SWI 0x090000
 	RET
+
 TEXT IntrMain(SB), $-4
 	RET
 /*
@@ -42,4 +62,68 @@
 
 	ldr	r2,=irqTable
 	
-	*/
\ No newline at end of file
+*/
+
+TEXT setr13(SB), $-4
+	MOVW		4(FP), R1
+
+	MOVW		CPSR, R2
+	BIC		$PsrMask, R2, R3
+	ORR		R0, R3
+	MOVW		R3, CPSR
+
+	MOVW		R13, R0
+	MOVW		R1, R13
+
+	MOVW		R2, CPSR
+	RET
+
+TEXT splhi(SB), $-4					
+	MOVW		CPSR, R0
+	ORR		$(PsrDirq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT spllo(SB), $-4
+	MOVW		CPSR, R0
+	BIC		$(PsrDirq|PsrDfiq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT splx(SB), $-4
+	/* BUG - save PC in m->splpc - JB */
+
+TEXT splxpc(SB), $-4
+	MOVW		R0, R1
+	MOVW		CPSR, R0
+	MOVW		R1, CPSR
+	RET
+
+TEXT islo(SB), $-4
+	MOVW		CPSR, R0
+	AND		$(PsrDirq), R0
+	EOR		$(PsrDirq), R0
+	RET
+
+TEXT splfhi(SB), $-4					
+	MOVW		CPSR, R0
+	ORR		$(PsrDfiq|PsrDirq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT splflo(SB), $-4
+	MOVW		CPSR, R0
+	BIC		$(PsrDfiq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT cpsrr(SB), $-4
+	MOVW		CPSR, R0
+	RET
+TEXT cpsrw(SB), $-4
+	MOVW		R0, CPSR
+	RET
+
+TEXT spsrr(SB), $-4
+	MOVW		SPSR, R0
+	RET
Index: arm7/ipc.c
===================================================================
--- arm7/ipc.c	(revision 24)
+++ arm7/ipc.c	(working copy)
@@ -2,7 +2,7 @@
 #include "../mem.h"
 #include "nds.h"
 
-TransferRegion  *getIPC() {
+TransferRegion  *getIPC(void) {
 	return (TransferRegion*)(0x027FF000);
 }
 static  void IPC_SendSync(unsigned int sync) {
Index: arm7/ipc.h
===================================================================
--- arm7/ipc.h	(revision 24)
+++ arm7/ipc.h	(working copy)
@@ -133,4 +133,4 @@
 };
 
 
-TransferRegion  *getIPC();
\ No newline at end of file
+TransferRegion  *getIPC(void);
Index: arm7/mem.h
===================================================================
--- arm7/mem.h	(revision 24)
+++ arm7/mem.h	(working copy)
@@ -19,3 +19,5 @@
 #define PsrN		0x80000000	/* negative/less than */
 
 #define KSTACK	8192			/* Size of kernel stack */
+
+#define IWRAMTOP7	(0x3810000)
Index: arm7/interrupts.h
===================================================================
--- arm7/interrupts.h	(revision 24)
+++ arm7/interrupts.h	(working copy)
@@ -142,15 +142,12 @@
 	IME_DISABLE = 0, 	/*!< Disable all interrupts. */
 	IME_ENABLE = 1,	/*!< Enable all interrupts not masked out in REG_IE */
 };
-/*
-extern VoidFunctionPointer	__irq_vector[];
-extern	vuint32	__irq_flags[];
-*/
-#define VBLANK_INTR_WAIT_FLAGS  *(__irq_flags)
-#define IRQ_HANDLER             *((VoidFunctionPointer*)INTHAND)
 
+#define IRQ_HANDLER (*(VoidFunctionPointer *)((int*)(IWRAMTOP7 - 4)))
+#define VBLANK_INTR_WAIT_FLAGS  *((int*)(IWRAMTOP7 - 8))
+
 struct IntTable{IntFn handler; u32 mask;};
-void irqInit();
+void irqInit(void);
 void irqset(int irq, VoidFunctionPointer handler);
 /* ! \fn irqClear(IRQ_MASK irq)
 	\brief remove the handler associated with the interrupt mask irq.
