Index: gsym
===================================================================
--- gsym	(revision 0)
+++ gsym	(revision 0)
@@ -0,0 +1,13 @@
+#!/bin/sh
+# usage: gsym addr symfile
+
+addr=$1
+if test -f $2; then
+	syms=$2
+fi
+
+# try to match addr by s/lowest addr char/./
+while ! grep -n $addr $syms /dev/null; do
+	addr=`echo $addr | 9 sed 's/([0-9a-f]+)[^.]/\1./'`
+	echo addr $addr
+done
Index: lcdtest.c
===================================================================
--- lcdtest.c	(revision 0)
+++ lcdtest.c	(revision 0)
@@ -0,0 +1,91 @@
+#include "u.h"
+#include "mem.h"
+#include "io.h"
+
+enum {
+	/* lccr */
+	Mode3 = 0x3,
+	Mode4 = 0x4,	/* only use mode 4 for Inferno */
+	Bg2enable = 0x400, /* enable display on the frame buffer */
+
+	/* lcsr */
+	EnableCtlr =~0x7,
+};
+
+void lcdgraphicscmap(ushort *palette);
+/* int setcolor(ulong p, ulong r, ulong g, ulong b); */
+
+//ushort *vramend = 0x06017FFF;
+ushort *vramend = VRAM + 18*1024*1024;
+
+#define RGB15(r,g,b)	((r)|(g<<5)|(b<<10))
+
+int
+lcdtestlink(void) {
+	int i, j, k;
+	ushort col;
+	LcdReg *lcd = SUBLCDREG;
+	ushort *palette = ((ushort*)PAL);
+	ushort *vram = ((ushort*)VRAM+1*1024*1024);
+
+	// Enable LCD
+	lcd->lccr = Mode4 | Bg2enable; /* | 0x800 | 0x100; */
+
+	//for(i = 0; i < 256; i++)
+	//	palette[i] = RGB15(i,i,i);
+	//lcdgraphicscmap(palette);
+	
+	for(i = 0; vram != vramend; vram+=1, i++ ) {
+		i &= 0xff;
+		col = i  | (i <<8);
+		*vram = col;
+		//dcflush(vram,1);
+	} 
+	dsconsinit();
+	print("reached\n");
+	//while(1);
+	return 0;	
+}
+
+void
+lcdgraphicscmap(ushort* palette)
+{
+	int num, den, i, j;
+	int r, g, b, cr, cg, cb, v, p;
+
+	for(r=0,i=0;r!=4;r++) 
+		for(v=0;v!=4;v++,i+=16){
+			for(g=0,j=v-r;g!=4;g++) 
+				for(b=0;b!=4;b++,j++){
+			den=r;
+			if(g>den) den=g;
+			if(b>den) den=b;
+			if(den==0)	// divide check -- pick grey shades
+				cr=cg=cb=v*17;
+			else{
+				num=17*(4*den+v);
+				cr=r*num/den;
+				cg=g*num/den;
+				cb=b*num/den;
+			}
+			p = (i+(j&15));
+
+			palette[p] =RGB15(cr*0x01010101,cg*0x01010101,cb*0x01010101);
+		}
+	}
+}
+
+/*
+int
+setcolor(ulong p, ulong r, ulong g, ulong b)
+{
+	p &= 0xff;
+
+	vd->colormap[p][0] = r;
+	vd->colormap[p][1] = g;
+	vd->colormap[p][2] = b;
+	palette16[p] = ;
+	lcd_setcolor(p, r, g, b);
+	return ~0;
+}
+*/
Index: sds
===================================================================
--- sds	(revision 27)
+++ sds	(working copy)
@@ -71,7 +71,8 @@
 	taslock
 	xalloc
 
-link	
+link
+#	lcdtest
 #	lcd
 #	ether589
 #	ethertdk
Index: l.s
===================================================================
--- l.s	(revision 27)
+++ l.s	(working copy)
@@ -1,5 +1,7 @@
 #include "mem.h"
 
+#define	CPWAIT	MRC	CpMMU, 0, R2, C(2), C(0), 0; MOVW R2, R2; SUB $4, R15
+
 /*
  * 		Entered from the boot loader with
  *		supervisor mode, interrupts disabled;
@@ -22,6 +24,10 @@
 
 GLOBL 		Mach0(SB), $KSTACK
 
+TEXT	getcpuid(SB), $-4
+	MRC		CpMMU, 0, R0, C(CpCPUID), C(0)
+	RET
+
 TEXT setr13(SB), $-4
 	MOVW		4(FP), R1
 
@@ -131,7 +137,8 @@
 	RET
 
 TEXT splx(SB), $-4
-	/* BUG - save PC in m->splpc - JB */
+	MOVW	$(MACHADDR), R6
+	MOVW	R14, (R6)	/* m->splpc */
 
 TEXT splxpc(SB), $-4
 	MOVW		R0, R1
@@ -205,23 +212,90 @@
 */
 	RET
 
+/*
+ * flush (invalidate) the whole icache
+ */
+TEXT icflushall(SB), $-4
+_icflushall:
+	MCR	 	CpMMU, 0, R0, C(CpCacheCtl), C(5), 0	/* clean i-cache and branch buffer */
+	CPWAIT
+	RET
 
+/*
+ * invalidate part of i-cache and  invalidate branch target buffer
+ */
+TEXT	icflush(SB), $-4
+	MOVW	4(FP), R1
+	CMP		$(ICACHESIZE/2), R1
+	BGE		_icflushall
+	ADD		R0, R1
+	BIC		$(CACHELINESZ-1), R0
+icflush1:
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(5), 1	/* clean entry */
+	ADD		$CACHELINESZ, R0
+	CMP		R1, R0
+	BLO	icflush1
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(5), 6	/* invalidate branch target buffer */
+	CPWAIT							
+	RET
+
+/*
+ * write back whole data cache and drain write buffer
+ */
+TEXT dcflushall(SB), $-4
+_dcflushall:
+	MOVW		$(DCFADDR), R0
+	ADD		$DCACHESIZE, R0, R1
+dcflushall1:
+	MCR	CpMMU, 0, R0, C(CpCacheCtl), C(2), 5	/* allocate line */
+	ADD		$CACHELINESZ, R0
+	CMP		R1,R0
+	BNE		dcflushall1
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(10), 4	/* drain write buffer */
+	CPWAIT
+	RET
+
+/*
+ * write back a given region and drain write buffer
+ */
+TEXT	dcflush(SB), $-4
+	MOVW	4(FP), R1
+	CMP		$(DCACHESIZE/2), R1
+	BGE		_dcflushall
+	ADD		R0, R1
+	BIC		$(CACHELINESZ-1), R0
+dcflush1:
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(10), 1	/* clean entry */
+	ADD		$CACHELINESZ, R0
+	CMP		R1, R0
+	BLO	dcflush1
+	MCR		CpMMU, 0, R0, C(CpCacheCtl), C(10), 4	/* drain write buffer */
+	CPWAIT							
+	RET
+
+/* nds specific bios calls, swi, ... */
+
 TEXT _halt(SB), $-4
-	SWI 0x02
+	SWI	0x02
 
 TEXT _reset(SB), $-4
-	SWI 0x0
+	SWI	0x0
 
 /* need to allow kernel to pass args on what to clear */	
 TEXT	_clearregs(SB), $-4
-	MOVW $0x4, R0
-	SWI 0x1
+	MOVW	$0x4, R0
+	SWI	0x1
 
 TEXT _stop(SB), $-4
 	MOVW $0xEAEAEA,R0
 
+TEXT swiDelay(SB), $-4
+	SWI	0x030000
+	RET
+
 TEXT	waitvblank(SB), $-4
-	SWI 0x050000
+	SWI	0x050000
+	RET
 
 TEXT getdtcm(SB), $-4
 	MRC		15,0,R0,C9,C1,0
@@ -232,8 +306,9 @@
 	RET
 
 TEXT writedtcmctl(SB), $-4
-	MCR		15,0,R0,C9,C1,0
+	MCR		CpMMU,0,R0,C9,C1,0
 	RET
+
 TEXT loop(SB), $-4
 wait:
 	B wait
Index: screen.c
===================================================================
--- screen.c	(revision 27)
+++ screen.c	(working copy)
@@ -182,7 +182,7 @@
 
 
 
-	vd = lcd_init(mode);
+	vd = lcd_init(mode, 0);
 	if(vd == nil)
 		panic("can't initialise LCD");
 
Index: devnds.c
===================================================================
--- devnds.c	(revision 27)
+++ devnds.c	(working copy)
@@ -5,6 +5,8 @@
 #include	"fns.h"
 #include	"io.h"
 #include	"../port/error.h"
+#include	<keyboard.h>
+
 #include 	"arm7/jtypes.h"
 #include	"arm7/ipc.h"
 #include	"arm7/touch.h"
@@ -66,7 +68,7 @@
 static Chan*
 ndsattach(char* spec)
 {
-	kproc("touchread", touchread, nil, 0);
+	if(1)kproc("touchread", touchread, nil, 0);
 	return devattach('T', spec);
 }
 
@@ -97,9 +99,9 @@
 static long
 ndsread(Chan* c, void* a, long n, vlong offset)
 {
-	char *tmp, buf[64];
-	uchar reply[12];
-	int v, p, l;
+	//char *tmp, buf[64];
+	//uchar reply[12];
+	//int v, p, l;
 
 	switch((ulong)c->qid.path){
 	case Qdir:
@@ -118,8 +120,8 @@
 static long
 ndswrite(Chan* c, void* a, long n, vlong)
 {
-	char cmd[64], op[32], *fielnds[6];
-	int nf;
+	//char cmd[64], op[32], *fielnds[6];
+	//int nf;
 	switch((ulong)c->qid.path){
 	case Qctl:
 		break;
@@ -131,31 +133,84 @@
 	}
 	return n;
 }
+
 enum {
-	Rbut=1<<8,
-	Abut=1,
-	Bbut=1<<1,
+	Abtn	=	1<<0,
+	Bbtn	=	1<<1,
+	Selbtn	=	1<<2,
+	Startbtn=	1<<3,
+	Rightbtn=	1<<4,
+	Leftbtn	=	1<<5,
+	Upbtn	=	1<<6,
+	Downbtn	=	1<<7,
+	Rbtn	=	1<<8,
+	Lbtn	=	1<<9,
 };
+
+// TODO extra keys x, y only accesible from arm7
+// also portrait and right/left handed
+static	Rune	rockermap[3][10] ={
+	{'\n', '\t', Del, SysRq, Right, Left, Up, Down, RCtrl, RShift},	// right handed
+	{'\n', '\t', Del, SysRq, Right, Left, Up, Down, RCtrl, RShift},	// left handed
+	{'?', '|', Del, SysRq, Right, Left, Up, Down, RCtrl, RShift},	// debug
+};
+
+// done on vblank irq why ? polling ?; the same for touchread
+// need a way to be notified when keys state changes
+// with this + debug_keys debugging should be eaiser
+// by registering debugkeys to perform checks
+static void 
+ndskeys(void)
+{
+	int i;
+	ushort state;
+	static ushort ostate;
+
+	//print("\n");
+	state = REG_KEYINPUT;
+	if (ostate == state)
+		return;
+	for (i = 0 ; i < nelem(rockermap[conf.bmap]) ; i++){
+		if ((state >> i) & 1){
+			kbdrepeat(0);
+		}else{
+			if (0)print("ndskeys: %#x %c(%d)\n", state, rockermap[conf.bmap][i], i);
+			kbdrepeat(0);
+			kbdputc(kbdq, rockermap[conf.bmap][i]);
+		}
+	}
+	ostate = state;
+	swiDelay(1000);
+}
+
+
 static void
 touchread(void*)
 {
 	int x=0, y=0, dx, dy, buttons, b, oldb=0, n=0;
+
 	for(;;) {
 	//	print("touchread iter\n");
-	//	if(!(IPC->buttons&Pendown))
-	//		continue; // should sleep until the pen is down
+		if(!(IPC->buttons&Pendown))
+			continue; // should sleep until the pen is down
 	//	dx=IPC->touchXpx-x;
 	//	dy=IPC->touchYpx-y;
 	/* have an option for handedness here? right now left handed */
-		buttons=~((IPC->buttons&Pendown)>>6|(REG_KEYINPUT&Rbut)>>6|(REG_KEYINPUT&Abut)<<1)&0x7;
-		if((b=!(REG_KEYINPUT&Bbut))^oldb && !n--) {
+		buttons=~((IPC->buttons&Pendown)>>6|(REG_KEYINPUT&Rbtn)>>6|(REG_KEYINPUT&Abtn)<<1)&0x7;
+		if((b=!(REG_KEYINPUT&Bbtn))^oldb && !n--) {
 			kbdputc(kbdq,'\n');
 			b=oldb;
 			n=500;
 		}
 		mousetrack(buttons, IPC->touchXpx, IPC->touchYpx, 0);
-	//	x=IPC->touchXpx;
-	//	y=IPC->touchYpx;
+		if(1)print("touchread iter %#d %d %d %d %X\n", 
+			IPC->touchX, IPC->touchY,
+			IPC->touchXpx, IPC->touchYpx, buttons);
+		ndskeys();
+		//waitvblank();
+		swiDelay(1000);
+	x=IPC->touchXpx;
+	y=IPC->touchYpx;
 	}
 }
 TransferRegion  *getIPC() {
Index: screen.h
===================================================================
--- screen.h	(revision 27)
+++ screen.h	(working copy)
@@ -54,7 +54,7 @@
 
 int	archlcdmode(LCDmode*);
 
-Vdisplay	*lcd_init(LCDmode*);
+Vdisplay	*lcd_init(LCDmode*, int which);
 void	lcd_setcolor(ulong, ulong, ulong, ulong);
 void	lcd_flush(void);
 
Index: mkfile
===================================================================
--- mkfile	(revision 27)
+++ mkfile	(working copy)
@@ -53,16 +53,17 @@
 CFLAGS=-wFV -I$ROOT/Inferno/$OBJTYPE/include -I$ROOT/include -I$ROOT/libinterp -r
 KERNDATE=`{ndate}
 
-default:V: i$CONF.nds # i$CONF.out
+default:V: i$CONF.nds i$CONF.out
 
 install:V: $INSTALLDIR/i$CONF $INSTALLDIR/i$CONF.gz $INSTALLDIR/i$CONF.p9.gz $INSTALLDIR/i$CONF.raw
 
 i$CONF: $OBJ $CONF.c $CONF.root.h $LIBNAMES
 	$CC $CFLAGS '-DKERNDATE='$KERNDATE $CONF.c
-	$LD -o $target  -H4  -T$KTZERO    -l $OBJ $CONF.$O $LIBFILES # -t 
+	$LD -o $target  -H4  -T$KTZERO    -l $OBJ $CONF.$O $LIBFILES
 
-arm7/$O.out:Pcmp -s:	/dev/null	# nasty but works, suggestions welcome
-	cd arm7; mk 5.out
+arm7/$O.out:Pfalse:	. # nasty but works, suggestions welcome
+	cd arm7
+	mk 5.out
 #	mk i5.out
 
 i$CONF.nds: i$CONF arm7/$O.out
@@ -72,7 +73,7 @@
 
 i$CONF.out: $OBJ $CONF.c $CONF.root.h $LIBNAMES
 	$CC $CFLAGS '-DKERNDATE='$KERNDATE $CONF.c
-	$LD -o $target -R0 -T$KTZERO -D$KDZERO   -l $OBJ $CONF.$O $LIBFILES >/dev/null # -t 
+	$LD -o $target -R0 -T$KTZERO -D$KDZERO   -l $OBJ $CONF.$O $LIBFILES
 	ksize $target
 
 <../port/portmkfile
Index: lcd.c
===================================================================
--- lcd.c	(revision 27)
+++ lcd.c	(working copy)
@@ -8,7 +8,7 @@
 #include	<memdraw.h>
 #include	"screen.h"
 #include	"lcdreg.h"
-#define	DPRINT	if(1)iprint
+#define	DPRINT	if(0)iprint
 
 enum {
 	/* lccr */
@@ -31,10 +31,11 @@
 
 ushort *bg0map = (ushort*)Scrbase(31);
 
-
-
-
 typedef struct {
+	LcdReg *LcdReg;
+	VramReg *VramReg;
+	PowerReg *PowerReg;
+	
 	Vdisplay;
 	LCDparam;
 	ushort*	palette;
@@ -44,6 +45,14 @@
 
 static LCDdisplay	*vd;	// current active display
 
+/* TO DO: limits us to a single display */
+static LCDdisplay main_display= {
+	(LcdReg*)LCD, (VramReg*)VRAM, (PowerReg*)POWER,
+};
+static LCDdisplay sub_display = {
+	(LcdReg*)SUBLCD, (VramReg*)VRAM, (PowerReg*)POWER,
+};
+
 void
 lcd_setcolor(ulong p, ulong r, ulong g, ulong b)
 {
@@ -54,46 +63,19 @@
 			(b>>(32-5));
 }
 
-static void
-disablelcd(void)
-{
-	LcdReg *lcd = LCDREG;
+#define SWAP_LCDS		1<<15
 
-	/* if LCD enabled, turn off */
-	if(lcd->lcsr & EnableCtlr) {
-		lcd->lcsr &= ~EnableCtlr;
-	}
-}
-
-static void
-setlcdmode(LCDdisplay *vd)
-{
-	LCDmode *p;
-	LcdReg *sublcd = SUBLCDREG;
-	LcdReg *lcd = LCDREG;
-	VramReg *vram = VRAMREG;
-	PowerReg *power = POWERREG;
-	p = (LCDmode*)&vd->Vmode;
-
-	disablelcd();
-	lcd->lccr = 0;	
-  	
- //	sublcd->lccr = MODE_0_2D | DISPLAY_BG0_ACTIVE;
-   	power->pcr = POWER_ALL_2D;
- 	lcd->lccr = MODE_FB0;
-      	vram->acr = VRAM_ENABLE|VRAM_A_LCD;
-
-	iprint("lccr=%8.8lux\n", lcd->lccr); 
-}
-static LCDdisplay main_display;	/* TO DO: limits us to a single display */
-
 Vdisplay*
-lcd_init(LCDmode *p)
+lcd_init(LCDmode *p, int which)
 {
-	int palsize;
-	int fbsize;
+	//int palsize=0;
+	int fbsize=0;
 
-	vd = &main_display;
+	if (!which)
+		vd = &main_display;
+	else
+		vd = &sub_display;
+	
 	vd->Vmode = *p;
 	vd->LCDparam = *p;
 	DPRINT("%dx%dx%d: hz=%d\n", vd->x, vd->y, vd->depth, vd->hz); /* */
@@ -106,28 +88,40 @@
 	vd->fb = vd->lower;
 	DPRINT("  fbsize=%d p=%p u=%p l=%p\n", fbsize, vd->palette, vd->upper, vd->lower); /* */
 
-	setlcdmode(vd);
+	blankscreen(0); /* LCD enabled */
+	
+  	vd->LcdReg->lccr = 0;
+	vd->VramReg->acr = VRAM_ENABLE|VRAM_A_LCD;
+	vd->PowerReg->pcr = POWER_ALL_2D;
+	vd->LcdReg->lccr = MODE_FB0;
+	
+	//vd->PowerReg->pcr &= ~SWAP_LCDS;
+	//vd->PowerReg->pcr ^= SWAP_LCDS;
+	DPRINT("lccr=%8.8lux\n", vd->LcdReg->lccr);
+	
 	return vd;
 }
 
+void dcflushall(void);
 void
 lcd_flush(void)
 {
 //		dcflushall();	/* need more precise addresses */
+		dcflush(vd->lower, vd->upper - vd->lower);
 }
 
 void
 blankscreen(int blank)
 {
-	LcdReg *lcd = LCDREG;
+	LcdReg *lcd = vd->LcdReg;
 	if(blank)
 		lcd->lcsr |= ~EnableCtlr;
 	else
 		lcd->lcsr |= EnableCtlr;			
 }
+
 void cmap(ushort* palette);
 
-
 #define RGB15(r,g,b)	((r)|(g<<5)|(b<<10))
 void
 cmap(ushort* palette)
@@ -160,13 +154,17 @@
 void
 dsconsinit(void)
 {
+	LCDmode lcd;
+	memset(&lcd, 0, sizeof(lcd));
+	if(archlcdmode(&lcd) < 0)
+		return;
 
-	ushort *palette = ((ushort*)PAL);
-	setlcdmode(vd);
-
-
+	lcd_init(&lcd, 0);
+	//vd->PowerReg->pcr |= SWAP_LCDS;
 }
+
 void
 uartputs(char* s, int n) {
+	USED(s, n);
 }
 
Index: mksymtab
===================================================================
--- mksymtab	(revision 27)
+++ mksymtab	(working copy)
@@ -1,9 +1,11 @@
 #!/bin/sh
 
 
-(echo 00000000 .arm; inm $1 | awk '
-BEGIN { s="00000000"} 
-{
-	print substr(s,0,8-length($1))$1,$3
-}
-')>ids.SYM
+(
+echo 00000000 .arm;
+inm -n $1 | awk '
+	BEGIN { s="00000000"} 
+	{
+		print substr(s,0,8-length($1))$1,$3
+	}
+') > $1.sym
Index: trap.c
===================================================================
--- trap.c	(revision 27)
+++ trap.c	(working copy)
@@ -52,6 +52,9 @@
 	if(v < 0 || v > MaxIRQbit)
 		panic("intrmask: irq source %d out of range\n", v);
 	INTREG->msk |= (1 << v);
+
+	// update REG_IRQCHECK for BIOS waits
+	 *((ulong*)0x00803FF8) |= (1 << v);
 }
 
 void
@@ -90,22 +93,17 @@
 	splx(x);
 }
 
-ulong fiqstack[4];
-ulong irqstack[4];
-ulong abtstack[4];
-ulong undstack[4];
-
 static void
 safeintr(Ureg *, void *a)
 {
 	int v = (int)a;
 	int x;
 
+	iprint("SPURIOUS INTERRUPT %d\n", v);
 	/* No handler - clear the mask so we don't loop */
 	x = splfhi();
 	intrmask(v, 0);
 	splx(x);
-//	iprint("SPURIOUS INTERRUPT %d\n", v);
 }
 
 static void
@@ -135,23 +133,29 @@
 	int i;
 //	writedtcmctl(0x00800000+0xa);
 //	intrhand = (ulong**)((getdtcm()&0xfffff000)+0x3ffc);
-	INTREG->master=1;
-//	INTREG->msk=1;
-//	INTREG->pnd=0xff;
+
+	INTREG->master=0;
+	INTREG->msk=0;
+	INTREG->pnd=~0;
+
 //	*((ulong*)0x04000214)=0xdeadbeef;
 	/* set up stacks for various exceptions */
-	setr13(PsrMfiq, fiqstack+nelem(fiqstack));
-	setr13(PsrMirq, irqstack+nelem(irqstack));
-	setr13(PsrMabt, abtstack+nelem(abtstack));
-	setr13(PsrMund, undstack+nelem(undstack)); 
+	setr13(PsrMfiq, m->fiqstack+nelem(m->fiqstack));
+	setr13(PsrMirq, m->irqstack+nelem(m->irqstack));
+	setr13(PsrMabt, m->abtstack+nelem(m->abtstack));
+	setr13(PsrMund, m->undstack+nelem(m->undstack)); 
 
-//	*intrhand = (ulong*)_virqcall; /* the GBA hardware handles interrupts */
+	(*(ulong*)0x00803FFC) = (ulong) _virqcall;
+//     *intrhand = (ulong*)_virqcall; /* the GBA hardware handles interrupts */
 
+
+
 	for (v = 0; v < nelem(Irq); v++) {
 		Irq[v].r = safeintr;
 		Irq[v].a = (void *)v;
 		Irq[v].v = v;
 	}
+	INTREG->master=1;
 
 	trapv(0x0, _vsvccall);
 	trapv(0x4, _vundcall);
Index: dat.h
===================================================================
--- dat.h	(revision 27)
+++ dat.h	(working copy)
@@ -31,6 +31,7 @@
 	ulong	cpuspeed;
 	ulong	pagetable;
 
+	int		bmap;				/* button map selection */
 	int		useminicache;		/* screen.c/lcd.c */
 	int		cansetbacklight;	/* screen.c/lcd.c */
 	int		cansetcontrast;		/* screen.c/lcd.c */
@@ -109,6 +110,12 @@
 	int	machno;
 	int	nrdy;
 
+	/* stacks for exceptions */
+	ulong   fiqstack[4];
+	ulong   irqstack[4];
+	ulong   abtstack[4];
+	ulong   undstack[4];
+		
 	int	stack[1];
 };
 
Index: mem.h
===================================================================
--- mem.h	(revision 27)
+++ mem.h	(working copy)
@@ -48,6 +48,7 @@
 #define KTZERO	(KZERO+0x00008010)
 #define KSTACK	8192			/* Size of kernel stack */
 
+#define FLUSHMEM	0x80000000	/* virtual address reserved for cache flushing */
 #define DCFADDR	FLUSHMEM	/* cached and buffered for cache writeback */
 #define MCFADDR	(FLUSHMEM+(1<<20))	/* cached and unbuffered for minicache writeback */
 #define UCDRAMZERO	0xC8000000	/* base of memory doubly-mapped as uncached */
@@ -59,10 +60,13 @@
  
 #define	EWRAMZERO	0x02000000
 #define	EWRAMTOP	0x023FFFFF
+#define	DWRAMZERO	0x0b000000
+#define	DWRAMTOP9	0x0b004000
 #define	IWRAMZERO	0x03000000
-#define	IWRAMTOP	0x03007FFF
-#define 	LCD			0x04000000	/* LCD controller */
-#define	SPI			0x040001C0	/* serial peripheral interface controller */
+#define	IWRAMTOP9	0x03007FFF
+#define	IWRAMTOP7	0x03810000
+#define	LCD		0x04000000	/* LCD controller */
+#define	SPI		0x040001C0	/* serial peripheral interface controller */
 #define	VRAM		0x04000240	/* Vram bank controller */
 #define	POWER		0x04000304	/* Power controller */
 #define	SUBLCD		0x04001000	/* sub LCD controller */
@@ -72,10 +76,18 @@
 #define	VRAMTOP		0x06800000
 #define	VRAMLO		0x06000000
 #define	VRAMHI		0x0600A000
-#define	INTHAND		0x03007FFC
+#define	INTHAND		0x03007FFC	// (DWRAMTOP9 - 4) ?
 #define	SFRbase		0x04000000
 #define	ROMZERO		0x08000000
+#define	EXMEMCNT	0x04000204
 
+#define OAM			0x07000000
+
+#define	CACHELINELOG	5
+#define	CACHELINESZ	(1<<CACHELINELOG)
+#define	DCACHESIZE	(4*1024)
+#define	ICACHESIZE	(8*1024)
+
 /*
  * PSR
  */
@@ -96,6 +108,28 @@
 #define PsrZ		0x40000000	/* zero */
 #define PsrN		0x80000000	/* negative/less than */
 
+/*
+ * Internal MPU coprocessor registers
+ */
+#define CpCPUID	0		/* R: opcode_2 is 0*/
+#define CpCacheID	0		/* R: opcode_2 is 1 */
+#define CpControl	1		/* R/W: control (opcode_2 is 0) */
+#define CpAuxctl	1		/* R/W: auxiliary control (opcode_2 is 1) */
+#define CpTTB		2		/* R/W: translation table base */
+#define CpDAC		3		/* R/W: domain access control */
+#define CpFSR		5		/* R/W: fault status */
+#define CpFAR		6		/* R/W: fault address */
+#define CpCacheCtl	7		/* W: */
+#define CpTLBops	8		/* W: TLB operations */
+#define CpCacheLk	9		/* W: cache lock down */
+#define CpPID		13		/* R/W: Process ID Virtual Mapping */
+#define CpDebug	14		/* R/W: debug registers */
+#define CpAccess	15		/* R/W: Coprocessor Access */
 
+/*
+ * Coprocessors
+ */
+#define CpMMU		15
+#define CpPWR		14
 
 #define TIMERbase	0x04000100	/* timers */
Index: main.c
===================================================================
--- main.c	(revision 27)
+++ main.c	(working copy)
@@ -82,6 +82,8 @@
 
 	conf.nproc = 100 + ((conf.npage*BY2PG)/MB)*5;
 	conf.nmach = 1;
+	
+	conf.bmap = 2;	// 0: right, 1: left, 2: debug
 }
 
 void
@@ -109,8 +111,9 @@
 void
 testintr()
 {
-	print("vblank intr\n");
-	
+	iprint("vblank intr\n");
+	intrmask(1<<0, 0);
+
 }
 
 #define idoc(m) if(1) uartputs(m, strlen(m));
Index: arm7/defaultARM7.c
===================================================================
--- arm7/defaultARM7.c	(revision 27)
+++ arm7/defaultARM7.c	(working copy)
@@ -1,42 +1,112 @@
 #include <u.h>
 #include "../mem.h"
+#include <kern.h>
 #include "nds.h"
 
-s32 getFreeSoundChannel();
+s32 getFreeSoundChannel(void);
+void irqhandler();
 void VblankHandler(void);
-void VcountHandler();
+void VcountHandler(void);
+void CommandProcessCommands(void);
 
-/* need to figure out the interrupt vector g __inter*/
+void setr13(int, ulong *);
+void splhi(void);
+void spllo(void);
+void poweron(int);
+
+/* So we can initialize our own data section and bss */
+extern char bdata[];
+extern char edata[];
+extern char end[];
+
+#define DMTEST if(0)memtest
+void 
+memtest(char val, int read){
+#define pc	((char*)(0x027FF000)) //+0x1000
+/*
+*/
+	int i;
+
+	for (i=0; i < sizeof(TransferRegion); i++){
+		if (read)
+			val = pc[i];
+		else{
+			pc[i] += 1;
+			pc[i] &= 0x0F;
+			pc[i] |= val;
+		}
+	}
+}
+
+ulong svcstack[KSTACK/4];
+ulong irqstack[24];
+ulong sysstack[128];
+
 int 
 main(int argc, char ** argv) 
 {
+	USED(argc, argv);
+	
+	setr13(PsrMsvc, svcstack+nelem(svcstack));
+	setr13(PsrMirq, irqstack+nelem(irqstack));
+	setr13(PsrMsys, sysstack+nelem(sysstack));
+	
+	DMTEST(0x00, 0);
+	/* fill out the data section by hand */
+	memset(edata, 0, end-edata); 		/* clear the BSS */
+	
+	// Set up the interrupt handler
+	REG_IME = 0;	
+	IRQ_HANDLER = irqhandler; // VcountHandler VblankHandler 
+	REG_IE = IRQ_VBLANK | IRQ_VCOUNT;
+	REG_IF = IRQ_ALL;
+	REG_DISPSTAT = DISP_VBLANK_IRQ;
+	REG_IME = 1;
+	
+	//splhi();
+	DMTEST(0x10, 0);
+	spllo();
+	
 //	readFirmware(0x03FE00,PersonalData,sizeof(PersonalData));
+	
 	poweron(POWER_SOUND);
 	SOUND_CR = SOUND_ENABLE | SOUND_VOL(0x7F);
-	for(;;) {
-		VblankHandler();
-		VcountHandler();
+
+//	for(;;) {
+//		VblankHandler();
+//		VcountHandler();
+//	}
+
+//	irqInit();
+//	initclkirq();
+//	irqset(IRQ_VBLANK, VblankHandler);
+//	setytrig(80);
+//	irqset(IRQ_VCOUNT, VcountHandler);
+//	irqen(IRQ_VBLANK);
+//	irqen(IRQ_VCOUNT);
+
+
+	DMTEST(0x20, 0);
+	// Keep the ARM7 out of main RAM
+	while (1) {
+		DMTEST(0x40, 0);
+		swiWaitForVBlank();
+		swiDelay(2000000);
 	}
-	irqInit();
-	initclkirq();
-	irqset(IRQ_VBLANK, VblankHandler);
-	setytrig(80);
-	irqset(IRQ_VCOUNT, VcountHandler);
-	irqen( IRQ_VBLANK | IRQ_VCOUNT);
-	while (1)
-		swiWaitForVBlank();
+	return 0;
 }
 
-void 
-startSound(int sampleRate, const void* data, u32 bytes, u8 channel, u8 vol,  u8 pan, u8 format) 
+void
+startSound(int rate, const void* data, u32 bytes, u8 chan, u8 vol,  u8 pan, u8 fmt) 
 {
-	SCHANNEL_TIMER(channel)  = SOUND_FREQ(sampleRate);
-	SCHANNEL_SOURCE(channel) = (u32)data;
-	SCHANNEL_LENGTH(channel) = bytes >> 2 ;
-	SCHANNEL_CR(channel)     = SCHANNEL_ENABLE | SOUND_ONE_SHOT | SOUND_VOL(vol) | SOUND_PAN(pan) | (format==1?SOUND_8BIT:SOUND_16BIT);
+	SCHANNEL_TIMER(chan)  = SOUND_FREQ(rate);
+	SCHANNEL_SOURCE(chan) = (u32)data;
+	SCHANNEL_LENGTH(chan) = bytes >> 2 ;
+	SCHANNEL_CR(chan)     = SCHANNEL_ENABLE | SOUND_ONE_SHOT | SOUND_VOL(vol) | SOUND_PAN(pan) | (fmt==1? SOUND_8BIT: SOUND_16BIT);
 }
-s32 
-getFreeSoundChannel()
+
+s32
+getFreeSoundChannel(void)
 {
 	int i;
 	for (i=0; i<16; i++) {
@@ -45,15 +115,18 @@
 	return -1;
 }
 
-
 void
-VcountHandler()
+VcountHandler(void)
 {
 	touchPosition tp = {0,0,0,0,0, 0};
 	static int lastpress = -1;
-	uint16 press=0, x=0, y=0, xpx=0, ypx=0, z1=0, z2=0;
+	uint16 press, x=0, y=0, xpx=0, ypx=0, z1=0, z2=0, batt, aux;
+	int t1,t2;
+	uint32 temp;
+	
 	press = REG_KEYXY;
-	if (!((press^lastpress)&Pendown)) {
+	
+	if (!((press^lastpress) & Pendown)) {
 		touchReadXY(&tp);
 		if ( tp.x == 0 || tp.y == 0 ) {
 			press |= Pendown;
@@ -70,6 +143,11 @@
 		lastpress = press;
 		press |= Pendown;
 	}
+	
+	batt = touchRead(Tscgetbattery);
+	aux  = touchRead(Tscgetaux);
+	temp = touchReadTemperature(&t1, &t2);
+	
 	IPC->touchX			= x; // x/14-24
 	IPC->touchY			= y; // y/18-12
 	IPC->touchXpx		= xpx;
@@ -77,6 +155,15 @@
 	IPC->touchZ1		= z1;
 	IPC->touchZ2		= z2;
 	IPC->buttons		= press;
+	IPC->battery		= batt;
+	IPC->aux			= aux;
+	IPC->tdiode1		= t1;
+	IPC->tdiode2		= t2;
+	IPC->temperature	= temp;
+
+	DMTEST(0x60, 0); 
+	REG_IF |= IRQ_VCOUNT;
+	VBLANK_INTR_WAIT_FLAGS  |= IRQ_VCOUNT;
 }
 
 void
@@ -92,4 +179,30 @@
 			}
 		}
 	}
+
+	DMTEST(0x50, 0); 
+	
+	// Acknowledge interrupts
+	VBLANK_INTR_WAIT_FLAGS  |= IRQ_VBLANK;
+	
+	REG_IF |= IRQ_VBLANK;
 }
+
+void
+irqhandler(){
+	//CommandProcessCommands();
+	
+	// this doesn't happen, why?
+	if (REG_IF & IRQ_VCOUNT)
+		VcountHandler();
+
+	//memtest(0x00, 0);
+	if (REG_IF & IRQ_VBLANK){
+		VcountHandler();
+		VblankHandler();
+	}
+
+	// ack any other int
+	REG_IF = REG_IF;
+}
+
Index: arm7/l.s
===================================================================
--- arm7/l.s	(revision 27)
+++ arm7/l.s	(working copy)
@@ -1,15 +1,20 @@
 #include "mem.h"
 
+/*
+ * 		Entered from the boot loader with
+ *		supervisor mode, interrupts disabled;
+ */
+
 TEXT _main(SB), $-4
-	MOVW		$setR12(SB), R12 	/* static base (SB) */
-/*	MOVW		$Mach0(SB), R13 */
-	ADD		$(KSTACK-4), R13	/* leave 4 bytes for link */
+//	MOVW	$setR12(SB), R12 	/* static base (SB) */
+//	/* MOVW	$Mach0(SB), R13 */
+//	ADD		$(KSTACK-4), R13	/* leave 4 bytes for link */
+//
+//	MOVW	$(PsrDirq|PsrDfiq|PsrMsvc), R1	/* Switch to SVC mode */
+//	MOVW	R1, CPSR
+//
+	B		main(SB)		/* jump to kernel */
 
-	MOVW		$(PsrDirq|PsrDfiq|PsrMsvc), R1	/* Switch to SVC mode */
-	MOVW		R1, CPSR
-
-
-	BL		main(SB)		/* jump to kernel */
 TEXT swiDelay(SB), $-4
 	SWI	0x030000
 	RET
@@ -20,6 +25,7 @@
 TEXT swiDivMod(SB), $-4
 	SWI 0x090000
 	RET
+
 TEXT IntrMain(SB), $-4
 	RET
 /*
@@ -42,4 +48,68 @@
 
 	ldr	r2,=irqTable
 	
-	*/
\ No newline at end of file
+*/
+
+TEXT setr13(SB), $-4
+	MOVW		4(FP), R1
+
+	MOVW		CPSR, R2
+	BIC		$PsrMask, R2, R3
+	ORR		R0, R3
+	MOVW		R3, CPSR
+
+	MOVW		R13, R0
+	MOVW		R1, R13
+
+	MOVW		R2, CPSR
+	RET
+
+TEXT splhi(SB), $-4					
+	MOVW		CPSR, R0
+	ORR		$(PsrDirq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT spllo(SB), $-4
+	MOVW		CPSR, R0
+	BIC		$(PsrDirq|PsrDfiq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT splx(SB), $-4
+	/* BUG - save PC in m->splpc - JB */
+
+TEXT splxpc(SB), $-4
+	MOVW		R0, R1
+	MOVW		CPSR, R0
+	MOVW		R1, CPSR
+	RET
+
+TEXT islo(SB), $-4
+	MOVW		CPSR, R0
+	AND		$(PsrDirq), R0
+	EOR		$(PsrDirq), R0
+	RET
+
+TEXT splfhi(SB), $-4					
+	MOVW		CPSR, R0
+	ORR		$(PsrDfiq|PsrDirq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT splflo(SB), $-4
+	MOVW		CPSR, R0
+	BIC		$(PsrDfiq), R0, R1
+	MOVW		R1, CPSR
+	RET
+
+TEXT cpsrr(SB), $-4
+	MOVW		CPSR, R0
+	RET
+TEXT cpsrw(SB), $-4
+	MOVW		R0, CPSR
+	RET
+
+TEXT spsrr(SB), $-4
+	MOVW		SPSR, R0
+	RET
Index: arm7/ipc.c
===================================================================
--- arm7/ipc.c	(revision 27)
+++ arm7/ipc.c	(working copy)
@@ -2,7 +2,7 @@
 #include "../mem.h"
 #include "nds.h"
 
-TransferRegion  *getIPC() {
+TransferRegion  *getIPC(void) {
 	return (TransferRegion*)(0x027FF000);
 }
 static  void IPC_SendSync(unsigned int sync) {
Index: arm7/serial.c
===================================================================
--- arm7/serial.c	(revision 27)
+++ arm7/serial.c	(working copy)
@@ -3,8 +3,8 @@
 #include "nds.h"
 
 void
-busywait() 
+busywait(void) 
 {
 	while (REG_SPICNT & SPI_BUSY)
 		swiDelay(1);
-}
\ No newline at end of file
+}
Index: arm7/ipc.h
===================================================================
--- arm7/ipc.h	(revision 27)
+++ arm7/ipc.h	(working copy)
@@ -133,4 +133,4 @@
 };
 
 
-TransferRegion  *getIPC();
\ No newline at end of file
+TransferRegion  *getIPC(void);
Index: arm7/serial.h
===================================================================
--- arm7/serial.h	(revision 27)
+++ arm7/serial.h	(working copy)
@@ -136,7 +136,7 @@
 
 int readPowerManagement(int reg);
 
-void busywait();
+void busywait(void);
 // Read the firmware
 void readFirmware(uint32 address, void * destination, uint32 size);
 
Index: arm7/mem.h
===================================================================
--- arm7/mem.h	(revision 27)
+++ arm7/mem.h	(working copy)
@@ -19,3 +19,5 @@
 #define PsrN		0x80000000	/* negative/less than */
 
 #define KSTACK	8192			/* Size of kernel stack */
+
+#define IWRAMTOP7	(0x3810000)
Index: arm7/interrupts.h
===================================================================
--- arm7/interrupts.h	(revision 27)
+++ arm7/interrupts.h	(working copy)
@@ -142,15 +142,12 @@
 	IME_DISABLE = 0, 	/*!< Disable all interrupts. */
 	IME_ENABLE = 1,	/*!< Enable all interrupts not masked out in REG_IE */
 };
-/*
-extern VoidFunctionPointer	__irq_vector[];
-extern	vuint32	__irq_flags[];
-*/
-#define VBLANK_INTR_WAIT_FLAGS  *(__irq_flags)
-#define IRQ_HANDLER             *((VoidFunctionPointer*)INTHAND)
 
+#define IRQ_HANDLER (*(VoidFunctionPointer *)((int*)(IWRAMTOP7 - 4)))
+#define VBLANK_INTR_WAIT_FLAGS  *((int*)(IWRAMTOP7 - 8))
+
 struct IntTable{IntFn handler; u32 mask;};
-void irqInit();
+void irqInit(void);
 void irqset(int irq, VoidFunctionPointer handler);
 /* ! \fn irqClear(IRQ_MASK irq)
 	\brief remove the handler associated with the interrupt mask irq.
